#include <stdio.h>
#include "demo.h"

void agx_disassemble(void *_code, size_t maxlen, FILE *fp);

#define AGX_STOP \
	0x88, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, \
	0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00 \

#define AGX_BLEND \
	0x09, 0x00, 0x00, 0x04, 0xf0, 0xfc, 0x80, 0x03

uint8_t vertex_shader[] = {
	// +imad w1, hunk1:10, h#32, hconst_0
	0x9e, 0x03, 0x4a, 0x02, 0x02, 0x80, 0x01, 0x00,

	// -iadd w2, w2, hconst_2
	0x0e, 0x05, 0xc2, 0x22, 0x18, 0x00, 0x00, 0x00,

	// load address [w1:w2] to [w0:w3] (TODO disasm)
	0x05, 0x01, 0x00, 0x05, 0x00, 0xc4, 0x32, 0x00,

	// unk38
	0x38, 0x00,

	// -fmul.32 w4, w0, hconst_8.unk
	0x1a, 0x89, 0xc0, 0x82, 0x18, 0x00,

	// -fmul.32 w0, w2, hconst_10.unk
	0x1a, 0x81, 0xc2, 0xa2, 0x18, 0x00,

	// -movi w8, #0
	0x62, 0x11, 0x00, 0x00, 0x00, 0x00,

	// -movi w2, #1.0f
	0x62, 0x05, 0x00, 0x00, 0x80, 0x3f,

	// -st_var w8, index:2
	0x11, 0x10, 0x82, 0x80,
	// -st_var w2, index:3
	0x11, 0x04, 0x83, 0x80,
	// -st_var w4, index:0
	0x11, 0x08, 0x80, 0x80,
	// -st_var w0, index:1
	0x91, 0x00, 0x81, 0x80,

	AGX_STOP
};

uint8_t fragment_shader[] = {
	/* Set a red colour */
	0x62, 0x00, 0x00, 0x3c, // MOVI HR0, #3c00 /* 1.0 */
	0x62, 0x02, 0x00, 0x00, // MOVI HR1, #0000 /* 0.0 */
	0x62, 0x04, 0x00, 0x3c, // MOVI HR2, #0000 /* 0.0 */
	0x62, 0x06, 0x00, 0x3c, // MOVI HR3, #3c00 /* 1.0 */

	/* what follows is a standard(?) fp16 writeout sequence */
	0x48, 0x00, 0xc2, 0x00, // UNK48
	0x48, 0x0c, 0x00, 0x00, // UNK48
	AGX_BLEND,
	AGX_STOP
};

uint8_t vert_aux0[] = {
	// load w0
	0x05, 0x01, 0x04, 0x0d, 0x00, 0xc4, 0x32, 0x00,

	// unk38
	0x38, 0x00,

	// i2f w4, ??
	0xbe, 0x89, 0x0a, 0x04, 0x2c, 0x00,

	// i2f w0, ??
	0xbe, 0x81, 0x0a, 0x24, 0x2c, 0x00,

	// fmul w2, w4, ???
	0x9a, 0x85, 0xc4, 0x02, 0x02, 0x00,

	// fround w2, h2[??], ??
	// XXX: disassembler is choking on what looks like csel?
	0x0a, 0x05, 0xc2, 0x82, 0x9a, 0x81, 0xc0, 0x02, 0x02, 0x00, 0x0a, 0x01,
	0xc0, 0x82, 0xc5, 0x08, 0x80, 0x3d, 0x00, 0x80, 0x30, 0x00, 0xc5, 0x00,
	0xa0, 0x3d, 0x00, 0x80, 0x30, 0x00,
	AGX_STOP
};

uint8_t frag_aux0[] = {
	/* ignored? */
};

/* involved with clearing the tilebuffer */
uint8_t frag_aux1[] = {
	// bitwise XXX
	0x7e, 0x01, 0x8c, 0x09, 0x80, 0x40,
	// bitwise XXX
	0x7e, 0x05, 0x8e, 0x09, 0x80, 0x00,
	AGX_BLEND,
	AGX_STOP
};

/* involved with clearing the tilebuffer */
uint8_t frag_aux2[] = {
	// -fadd.32 {h2, h3, h0, h1}, hconst_{4, 6, 8, 10}.unk, h#0 /* unk5 = 02 */
	0x2a, 0x84, 0x84, 0x01, 0x00, 0x02,
	0x2a, 0x86, 0x86, 0x01, 0x00, 0x02,
	0x2a, 0x80, 0x88, 0x01, 0x00, 0x02,
	0x2a, 0x82, 0x8a, 0x01, 0x00, 0x02,

	// store
	0xc5, 0x08, 0xc0, 0x3d, 0x00, 0x80, 0x30, 0x00,
	// store
	0xc5, 0x00, 0xe0, 0x3d, 0x00, 0x80, 0x30, 0x00,

	AGX_STOP
};

uint8_t frag_aux3[] = {
	// something bitwise XXX
	0x7e, 0x00, 0x04, 0x09, 0x80, 0x00,
	// maybe varying related?
	0xb1, 0x80, 0x00, 0x80, 0x00, 0x4a, 0x00, 0x00, 0x0a, 0x00,
	AGX_STOP
};

uint8_t frag_aux4[] = {
	// +movi h0, #0x3C00
	0xe2, 0x00, 0x00, 0x3c,
	// -icsel.unk8 h0, hconst_4, h#0, h#0
	0x12, 0x00, 0x84, 0x01, 0x00, 0x00, 0x01, 0x8c,
	// some sort of store
	0xc5, 0x00, 0x60, 0x3d, 0x00, 0x80, 0x10, 0x00,

	AGX_STOP
};

uint8_t unk_aux0[] = {
	// XXX: why does this not have a stop? maybe this isn't even code?
	0x02, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x02, 0x01, 0x00, 0x00, 0x18, 0x01, 0x00, 0x00,
	0x02, 0x01, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00,
};

uint32_t
demo_upload_shader(const char *label, struct agx_allocator *allocator, uint8_t *code, size_t sz)
{
#if 0
	printf("%s:\n", label);
	agx_disassemble(code, sz, stdout);
	printf("\n");
#endif
	(void) label;

	return agx_upload(allocator, code, sz);
}

uint32_t
demo_vertex_shader(struct agx_allocator *allocator)
{
	return demo_upload_shader("vs", allocator, vertex_shader, sizeof(vertex_shader));
}

uint32_t
demo_fragment_shader(struct agx_allocator *allocator)
{
	return demo_upload_shader("fs", allocator, fragment_shader, sizeof(fragment_shader));
}

uint32_t
demo_unk_aux0(struct agx_allocator *allocator)
{
	return demo_upload_shader("unk", allocator, unk_aux0, sizeof(unk_aux0));
}

uint32_t
demo_vert_aux0(struct agx_allocator *allocator)
{
	return demo_upload_shader("vert_aux0", allocator, vert_aux0, sizeof(vert_aux0));
}

uint32_t
demo_frag_aux0(struct agx_allocator *allocator)
{
	return demo_upload_shader("frag_aux0", allocator, frag_aux0, sizeof(frag_aux0));
}

uint32_t
demo_frag_aux1(struct agx_allocator *allocator)
{
	return demo_upload_shader("frag_aux1", allocator, frag_aux1, sizeof(frag_aux1));
}

uint32_t
demo_frag_aux2(struct agx_allocator *allocator)
{
	return demo_upload_shader("frag_aux2", allocator, frag_aux2, sizeof(frag_aux2));
}

uint32_t
demo_frag_aux3(struct agx_allocator *allocator)
{
	return demo_upload_shader("frag_aux3", allocator, frag_aux3, sizeof(frag_aux3));
}

uint32_t
demo_frag_aux4(struct agx_allocator *allocator)
{
	return demo_upload_shader("frag_aux4", allocator, frag_aux4, sizeof(frag_aux4));
}
